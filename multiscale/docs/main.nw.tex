\documentclass[]{article}% ===> this file was generated automatically by noweave --- better not edit it
\usepackage[margin=10mm, left=25mm]{geometry}
\usepackage{pgf,tikz}
\usepackage{noweb}
\usepackage{amsmath}
\usepackage{color}
\usepackage{amssymb}
\usepackage{listings}
\usepackage[xindy]{glossaries}

\usetikzlibrary{circuits.logic.US}
\usetikzlibrary{positioning}
\usetikzlibrary{matrix}
 
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{
  basicstyle=\footnotesize\ttfamily, % the size of the fonts that are used for the code
  numbers=left,                      % where to put the line-numbers
  numberstyle=\tiny\color{gray},     % the style that is used for the line-numbers
  stepnumber=2,                      % the step between two line-numbers. If it's 1, each line
  numbersep=5pt,                     % how far the line-numbers are from the code
  backgroundcolor=\color{white},     % choose the background color. You must add \usepackage{color}
  showspaces=false,                  % show spaces adding particular underscores
  showstringspaces=false,            % underline spaces within strings
  showtabs=false,                    % show tabs within strings adding particular underscores
  rulecolor=\color{black},           % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. commens (green here))
  tabsize=2,                         % sets default tabsize to 2 spaces
  captionpos=b,                      % sets the caption-position to bottom
  breaklines=true,                   % sets automatic line breaking
  breakatwhitespace=false,           % sets if automatic breaks should only happen at whitespace
  keywordstyle=\color{blue},         % keyword style
  commentstyle=\color{dkgreen},      % comment style
  stringstyle=\color{mauve},         % string literal style
  morekeywords={*,...}               % if you want to add more keywords to the set
}
\usepackage{amsthm}
\usepackage{todonotes}
\usepackage{hyperref}
\setlength{\parskip}{3mm}
\newtheorem{axiom}{Axiom}
\newtheorem{definition}{Definition}
\newtheorem{comment}{Comment}
\newtheorem{example}{Example}
\newtheorem{lemma}{Lemma}
\newtheorem{prop}{Property}
\newtheorem{problem}{Problem}
\newtheorem{remark}{Remark}
\newtheorem{note}{Note}
\newtheorem{theorem}{Theorem}

% Title Page
\title{\textbf{Developer document} \\
Multiscale modelling in \href{www.moose.ncbs.res.in}{Moose}}
\author{Dilawar Singh \footnote{Junior Research Fellow at National Center for
Biological Sciences. Ph.D. candidate at EE IIT Bombay (currently on leave)} \\
\texttt{dilawars@ncbs.res.in}}
\date{\today}

\begin{document}
\maketitle

\begin{abstract}
\label{abstract}

  This documentation is a literate program. This describes and ongoing attempt
  to make moose more capable of doing multi-scale modelling. There are various
  XML based models available, each describing a particular aspect of neural
  activities. Some describes the chemical activities inside neuron while some
  other describe their electrical properties etc. We wish to write a super-XML
  model which can make use of all these models and map them onto moose.
  Currently, we call it {\Tt{}adaptorML\nwendquote}. Later we should find a cool name for it
  such as {\Tt{}mooseML\nwendquote} or {\Tt{}mooooml\nwendquote}.

\end{abstract}

\paragraph{Dependencies}

  You need {\Tt{}noweb\nwendquote} tool to generate documentation from this file. This file
  contains some macros which are not understood by {\Tt{}noweb\nwendquote}. These macros are
  used by a python script {\Tt{}./pynoweb.py\nwendquote} to generate {\Tt{}noweb\nwendquote} file. You need
  not know how to use it. Just run {\Tt{}./generate{\_}code{\_}and{\_}docs.sh\ --doc\nwendquote} to
  generate documentation after installing {\Tt{}noweb\nwendquote}.  Run the same command
  without {\Tt{}--doc\nwendquote} switch and you have your working application in {\Tt{}src\nwendquote}
  directory. 
  
  Contact the very friendly Homo Sapience Sapience named
  \href{mailto:dilawars@ncbs.res.in}{Dilawar Singh} if you need any help.
  He can be reached at \url{dilawars@ncbs.res.in}.
  \todo[color=red!60]{Write introduction to multiscale modelling}

\section{Initialize store-house}
\label{sec:setup}

\paragraph{Dependencies and import}

  We need {\Tt{}lxml.etree\nwendquote} for XML parsing. To print error and warning messages, I
  wrote a small module {\Tt{}DebugModule\nwendquote} \ref{sec:debug}. This module is
  implemented in file {\Tt{}debug.nw\nwendquote}. 
  
\paragraph{Imports}

  This chunk {\Tt{}Imports\nwendquote} keeps the essentials modules which we'll need in almost
  all files. We might occasionally also need a logger from python {\Tt{}logging\nwendquote}
  library. Let's create a standard logger too.

\nwfilename{.noweb/main.nw}\nwbegincode{1}\sublabel{NW3PuaTs-1rIojj-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3PuaTs-1rIojj-1}}}\moddef{Import~{\nwtagstyle{}\subpageref{NW3PuaTs-1rIojj-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3PuaTs-FYkKg-1}\\{NW3PuaTs-3sbhWR-1}\\{NW3PuaTs-1A5j6P-1}}\nwenddeflinemarkup
# Basic imports
import os 
import sys 
import logging 
import debug 

logger = logging.getLogger('multiscale')
from lxml import etree

\eatline
\nwused{\\{NW3PuaTs-FYkKg-1}\\{NW3PuaTs-3sbhWR-1}\\{NW3PuaTs-1A5j6P-1}}\nwendcode{}\nwbegindocs{2}\nwdocspar
\paragraph{Entry point}

  This is entry point of this program. Let's write down the sturcture of
  program. This is what we want to do in this application.
  
%file:src/main.py
\nwenddocs{}\nwbegincode{3}\sublabel{NW3PuaTs-FYkKg-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3PuaTs-FYkKg-1}}}\moddef{main.py~{\nwtagstyle{}\subpageref{NW3PuaTs-FYkKg-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
\LA{}Import~{\nwtagstyle{}\subpageref{NW3PuaTs-1rIojj-1}}\RA{}
\LA{}functions in main~{\nwtagstyle{}\subpageref{NW3PuaTs-4IIwDq-1}}\RA{}
\LA{}argument parser~{\nwtagstyle{}\subpageref{NW3PuaTs-86zu3-1}}\RA{}
\LA{}parse xml models and handover control to main class~{\nwtagstyle{}\subpageref{NW3PuaTs-4bnFmj-1}}\RA{}

\eatline
\nwnotused{main.py}\nwendcode{}\nwbegindocs{4}\nwdocspar
\paragraph{Argument parser}

  This application accepts paths of XML based models from command line. More
  than one XML model can be passed from command line. Python comes with a
  standard library {\Tt{}argparse\nwendquote} well suited to do this job. If more than two
  XML models are to be passed, each should be passed with its own {\Tt{}--xml\nwendquote}
  switch e.g. to pass {\Tt{}modelA.xml\nwendquote} and {\Tt{}modelB.xml\nwendquote} from command line, use
  the string {\color{blue}{\Tt{}--xml\ modelA.xml\ --xml\ modelB.xml\nwendquote}}. We must also
  provide the path of {\Tt{}adaptorML\nwendquote} file.

\nwenddocs{}\nwbegincode{5}\sublabel{NW3PuaTs-86zu3-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3PuaTs-86zu3-1}}}\moddef{argument parser~{\nwtagstyle{}\subpageref{NW3PuaTs-86zu3-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3PuaTs-FYkKg-1}}\nwenddeflinemarkup
# standard module for building a command line parser.
import argparse

# This section build the command line parser
argParser = argparse.ArgumentParser(description= 'Mutiscale modelling of neurons')
argParser.add_argument('--nml', metavar='nmlpath'
    , required = True
    , nargs = '+'
    , help = 'nueroml model'
    )
argParser.add_argument('--sbml', metavar='nmlpath'
    , nargs = '*'
    , help = 'sbml model'
    )
argParser.add_argument('--mechml', metavar='mechml'
    , nargs = '*'
    , help = 'mechml model'
    )
argParser.add_argument('--chml', metavar='channelml'
    , nargs = '*'
    , help = 'Channelml model'
    )
argParser.add_argument('--3dml', metavar='3dml'
    , nargs = '*'
    , help = '3DMCML model'
    )
argParser.add_argument('--meshml', metavar='meshml'
    , nargs = '*'
    , help = 'MeshML model'
    )
argParser.add_argument('--adaptor', metavar='adaptor'
    , required = True
    , nargs = '+'
    , help = 'AdaptorML for moose'
    )
args = argParser.parse_args()

\eatline
\nwused{\\{NW3PuaTs-FYkKg-1}}\nwendcode{}\nwbegindocs{6}\nwdocspar
  Once we have verified paths of XML models, we need a module to parse them. For
  the purpose of modularity, we wrote this module in its on literate file
  {\Tt{}parser.nw\nwendquote} and you can see its documentation in section \ref{sec:parser}.


\paragraph{Parse XML models}

  But before we parse, we need a helper function to check if given paths exists
  and are readable.

\nwenddocs{}\nwbegincode{7}\sublabel{NW3PuaTs-4IIwDq-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3PuaTs-4IIwDq-1}}}\moddef{functions in main~{\nwtagstyle{}\subpageref{NW3PuaTs-4IIwDq-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3PuaTs-FYkKg-1}}\nwenddeflinemarkup
def ifPathsAreValid(paths) :
  ''' Verify if path exists and are readable. '''
  if paths :
    paths = vars(paths)
    for p in paths :
      if not paths[p] : continue
      for path in paths[p] :
        if not path : continue
        if os.path.isfile(path) : pass
        else :
          debug.printDebug("ERROR"
            , "Filepath \{0\} does not exists".format(path))
          return False
      # check if file is readable 
      if not os.access(path, os.R_OK) :
        debug.printDebug("ERROR", "File \{0\} is not readable".format(path))
  return True

\eatline
\nwused{\\{NW3PuaTs-FYkKg-1}}\nwendcode{}\nwbegindocs{8}\nwdocspar

\paragraph{Parse XML files}

  At least one model must be provided by the user.  Validation is not enable in
  this version. \todo[inline, color=red!60]{Download new neuroML2 models and
  turn validate=True in {\Tt{}parseModels\nwendquote} function call.}

\nwenddocs{}\nwbegincode{9}\sublabel{NW3PuaTs-4bnFmj-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3PuaTs-4bnFmj-1}}}\moddef{parse xml models and handover control to main class~{\nwtagstyle{}\subpageref{NW3PuaTs-4bnFmj-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3PuaTs-FYkKg-1}}\nwenddeflinemarkup
import parser
if args : 
  if ifPathsAreValid(args) :
    logger.info("Started parsing XML models")
    debug.printDebug("INFO", "Started parsing XML models")
    etreeDict = parser.parseModels(args, validate=False)
    debug.printDebug("INFO", "Parsing of models is done")
    \LA{}hand over control to class in multiscale module~{\nwtagstyle{}\subpageref{NW3PuaTs-1butCV-1}}\RA{}
    print("Done!")
  else :
    debug.printDebug("FATAL", "One or more model file does not exists.")
    sys.exit()
else :
  debug.printDebug("FATAL", "Please provide at least one model. None given.")
  sys.exit()

\eatline
\nwused{\\{NW3PuaTs-FYkKg-1}}\nwendcode{}\nwbegindocs{10}\nwdocspar
\paragraph{Create multi-scale models in Moose}
  
  We are done initializing our application. Lets define a class {\Tt{}Multiscale\nwendquote}
  and hand over the control to its object. This class is defined in 
  {\Tt{}multiscale.nw\nwendquote}. We need to import module {\Tt{}multiscale\nwendquote} to be able to
  initialize and object of this class.

\nwenddocs{}\nwbegincode{11}\sublabel{NW3PuaTs-1butCV-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3PuaTs-1butCV-1}}}\moddef{hand over control to class in multiscale module~{\nwtagstyle{}\subpageref{NW3PuaTs-1butCV-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3PuaTs-4bnFmj-1}}\nwenddeflinemarkup
import multiscale
multiScaleObj = multiscale.Multiscale(etreeDict)
multiScaleObj.buildMultiscaleModel()
\eatline
\nwused{\\{NW3PuaTs-4bnFmj-1}}\nwendcode{}\nwbegindocs{12}\nwdocspar
Over to \ref{sec:multiscale}.

\section{Construct a Database/AST from XML models}
\label{sec:multiscale}
  
  This is our defining module and it contains the basic functionality of this
  application. All XML modules are parsed into a dictionary and this dictionary
  is passed to the object of class {\Tt{}Multiscale\nwendquote} which is the main class in
  this module. We also have {\Tt{}adaptorML\nwendquote} file parsed in dictionary. 

\begin{remark}{Why AST/Database?}
 
 Should I directly map XML models to moose objects or a intermediate
 representation would be better. I am leaning towards haivng a intermediate
 sqlite3 based data-structure. The benefit of using sqlite is that we can simply
 insert and query the database without having to keep all XML models open. We'll
 simply populate the database for each given model. Details are bit hazy in my
 mind right now and I should add the them to this document as they become
 clearer to me.

\end{remark}
 
\paragraph{Structure} Structure of this module is following. 

%file:src/multiscale.py
\nwenddocs{}\nwbegincode{13}\sublabel{NW3PuaTs-3sbhWR-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3PuaTs-3sbhWR-1}}}\moddef{multiscale~{\nwtagstyle{}\subpageref{NW3PuaTs-3sbhWR-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
\LA{}Import~{\nwtagstyle{}\subpageref{NW3PuaTs-1rIojj-1}}\RA{}
\LA{}Local imports~{\nwtagstyle{}\subpageref{NW3PuaTs-16aZsn-1}}\RA{}
\LA{}Definition of class \code{}Multiscale\edoc{}~{\nwtagstyle{}\subpageref{NW3PuaTs-2NXV7C-1}}\RA{}

\eatline
\nwnotused{multiscale}\nwendcode{}\nwbegindocs{14}\nwdocspar
\paragraph{A skeleton of class}

  Now we have parsed XML. We are passing the parsed XML in dictionary to a
  method {\Tt{}buildMultiscaleModel\nwendquote} of this class. We know, what this class must
  have at this point. Let's write it down and we'll wonder later how to add more
  functionality. 
  
\nwenddocs{}\nwbegincode{15}\sublabel{NW3PuaTs-2NXV7C-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3PuaTs-2NXV7C-1}}}\moddef{Definition of class \code{}Multiscale\edoc{}~{\nwtagstyle{}\subpageref{NW3PuaTs-2NXV7C-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3PuaTs-3sbhWR-1}}\nwenddeflinemarkup

class Multiscale :
  
  def __init__(self, xmlDict) :
    self.xmlDict = xmlDict 
    \LA{}initialize members~{\nwtagstyle{}\subpageref{NW3PuaTs-3OEhdK-1}}\RA{}
    debug.printDebug("INFO", "Object of class Multiscale intialized ...")

  \LA{}methods~{\nwtagstyle{}\subpageref{NW3PuaTs-2afNuv-1}}\RA{} 

  # This is the entry point of this class.
  def buildMultiscaleModel(self) :
      debug.printDebug("INFO", "Starting to build multiscale model")   
      \LA{}flow of executation~{\nwtagstyle{}\subpageref{NW3PuaTs-354DF8-1}}\RA{}
  
  def exit(self) :
    # Clean up before you leave
    \LA{}clean up the mess~{\nwtagstyle{}\subpageref{NW3PuaTs-2JMucE-1}}\RA{}

  # Write down the tests, whenever needed.
  \LA{}tests~{\nwtagstyle{}\subpageref{nw@notdef}}\RA{}



\eatline
\nwused{\\{NW3PuaTs-3sbhWR-1}}\nwendcode{}\nwbegindocs{16}\nwdocspar
Before we move on, lets discuss some models developed by others we need to
import into moose.

\section{Traub models and their translation into Python}
\label{subsec:traub}

This file is based on file {\Tt{}proto8.py\nwendquote}. Following is based on the header of
this file.

\paragraph{Model information}

 This implementation is mostly based on on the
 \href{thttp://www.genesis-sim.org/GENESIS/Tutorials/cells/traubcell/traub91proto.g}{graub91proto.g}
 by Dave Beeman. Main difference is addition of Glu and NMDA \footnote{A
 predominant molecular device for controlling synaptic plasticity and memory
 function} channels. The 1991 Traub set of voltage and concentration dependent
 channels implemented as tabchannels by Dave Beeman R.D.Traub, R. K.  S. Wong,
 R. Miles, and H.  Michelson Journal of Neurophysiology, Vol. 66, p. 635 (1991)

 This file depends on functions and constants defined in defaults.g
 As it is also intended as an example of the use of the tabchannel
 object to implement concentration dependent channels, it has extensive
 comments.  Note that the original units used in the paper have been
 converted to SI (MKS) units.  Also, we define the ionic equilibrium 
 potentials relative to the resting potential, {\Tt{}EREST{\_}ACT\nwendquote}.  In the
 paper, this was defined to be zero.  Here, we use -0.060 volts, the
 measured value relative to the outside of the cell.

 November 1999 update for GENESIS 2.2: Previous versions of this file used
 a combination of a table, {\Tt{}tabgate\nwendquote}, and {\Tt{}vdep{\nwbackslash}{\_}channel\nwendquote} to implement the
 Ca-dependent K Channel - $K(C)$.  This new version uses the new tabchannel
 "instant" field, introduced in GENESIS 2.2, to implement an
 "instantaneous" gate for the multiplicative Ca-dependent factor in the
 conductance.   This allows these channels to be used with the fast
 {\Tt{}hsolve\nwendquote}  chanmodes > 1.

 This Traub model is now converted to an equivalent python model described here.
 It is used in {\Tt{}pymoose\nwendquote}.


%file:src/proto.py
\nwenddocs{}\nwbegincode{17}\sublabel{NW3PuaTs-3Z31po-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3PuaTs-3Z31po-1}}}\moddef{proto.py~{\nwtagstyle{}\subpageref{NW3PuaTs-3Z31po-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
import moose
import numpy
import math

\LA{}Define constants~{\nwtagstyle{}\subpageref{NW3PuaTs-n1AAP-1}}\RA{}
\LA{}Functions to create channels~{\nwtagstyle{}\subpageref{NW3PuaTs-2PoeyK-1}}\RA{}
\LA{}Functions to maniputate property of channels~{\nwtagstyle{}\subpageref{NW3PuaTs-6Nalz-1}}\RA{}
\LA{}Glu receptor~{\nwtagstyle{}\subpageref{NW3PuaTs-1ReWpr-1}}\RA{}
\LA{}NMDA receptor~{\nwtagstyle{}\subpageref{NW3PuaTs-3DOkbq-1}}\RA{}
\LA{}Spike detector~{\nwtagstyle{}\subpageref{NW3PuaTs-1UDn2J-1}}\RA{}
\eatline
\nwnotused{proto.py}\nwendcode{}\nwbegindocs{18}\nwdocspar
\paragraph{Constants in model}

  \begin{table}[h]
    \centering
    \begin{tabular}{rll}
    \hline
    EREST\_ACT & Hippocampal cell resting potentional & $Volt$ \\
    ENA        & Equilibrium potential of Sodium      & $Volt$ \\
    EK         & Equilibrium potential of Potassium   & $Volt$ \\
    ECA        & Equilibrium potential of Calcium     & $Volt$ \\
    SOMA\_A    & Area of soma                         & $m^2$ \\
    \hline
    \end{tabular}
    \caption{Constants in this model}
  \end{table}

\nwenddocs{}\nwbegincode{19}\sublabel{NW3PuaTs-n1AAP-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3PuaTs-n1AAP-1}}}\moddef{Define constants~{\nwtagstyle{}\subpageref{NW3PuaTs-n1AAP-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3PuaTs-3Z31po-1}}\nwenddeflinemarkup
EREST_ACT = -0.060      # /* hippocampal cell resting potl */
ENA = 0.115 + EREST_ACT # // 0.055
EK = -0.015 + EREST_ACT # // -0.075
ECA = 0.140 + EREST_ACT # // 0.080
SOMA_A = 3.320e-9       # // soma area in square meters
\eatline
\nwused{\\{NW3PuaTs-3Z31po-1}}\nwendcode{}\nwbegindocs{20}\nwdocspar
\paragraph{Channels in model}
 
 For these channels, the maximum channel conductance ($Gbar$) has been
 calculated using the {\Tt{}CA3\nwendquote} \footnote{hippocampal pyramidal cell} soma channel
 conductance densities and soma area.  Typically, the functions which create
 these channels will be used to create a library of prototype channels.  When
 the cell reader creates copies of these channels in various compartments, it
 will set the actual value of Gbar by calculating it from the cell parameter
 file.


\nwenddocs{}\nwbegincode{21}\sublabel{NW3PuaTs-2PoeyK-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3PuaTs-2PoeyK-1}}}\moddef{Functions to create channels~{\nwtagstyle{}\subpageref{NW3PuaTs-2PoeyK-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3PuaTs-3Z31po-1}}\nwenddeflinemarkup
\LA{}Ordinary Ca channel~{\nwtagstyle{}\subpageref{NW3PuaTs-2eO7lE-1}}\RA{}
\LA{}Ca-dependent K-AHP channel~{\nwtagstyle{}\subpageref{NW3PuaTs-42jzWM-1}}\RA{}
\LA{}Ca-dependent K-C channel~{\nwtagstyle{}\subpageref{NW3PuaTs-45myvV-1}}\RA{}
\LA{}Tabchannel Na Hippocampal cell channel~{\nwtagstyle{}\subpageref{NW3PuaTs-2q0tl2-1}}\RA{}
\LA{}Tabchannel K-DR Hippocampal cell channel~{\nwtagstyle{}\subpageref{NW3PuaTs-1kzgPQ-1}}\RA{}
\LA{}Tabchannel K-A Hippocampal cell channell~{\nwtagstyle{}\subpageref{NW3PuaTs-2nYwmT-1}}\RA{}

\eatline
\nwused{\\{NW3PuaTs-3Z31po-1}}\nwendcode{}\nwbegindocs{22}\nwdocspar
\paragraph{Tabulated Calcium channel}
    

\begin{note}{This note is from Traub's model written in Fortran}

Often, the alpha and beta rate parameters can be expressed in the functional
form $y = \frac{A + Bx}{C + \exp{\frac{x + D}{F}}}$.  When this is the case, the
command {\Tt{}setupalpha\ chan\ gate\ AA\ AB\ AC\ AD\ AF\ BA\ BB\ BC\ BD\ BF\nwendquote} can be used to
simplify the process of initializing the A and B tables for the X, Y and Z
gates.  Although {\Tt{}setupalpha\nwendquote} has been implemented as a compiled GENESIS
command, it is also defined as a script function in the
{\Tt{}neurokit/prototypes/defaults.g\nwendquote} file.  Although this command can be used as a
"black box", its definition shows some nice features of the {\Tt{}tabchannel\nwendquote}
object, and some tricks we will need when the rate parameters do not fit this
form.

\end{note}

 We can give a short summary of the variables used in this function and
 relationship among them.

\begin{equation}
Gbar = {Gk}X^{Xpower}Y^{Ypower}Z^{Zpower}
\end{equation}

\begin{table}[h!]
\centering
 \begin{tabular}[h]{lrr}
 \hline \\
 Ek & Reversal potential of channel & constant\\
 Gk & Channel conductance & variable \\
 Gbar & Maximum channel conductance & constant \\
 Xpower \footnote{See "The book of genesis" for explaination on this model}
        & Power of X-gate & constant \\ 
 Ypower & Power of Y gate & constant \\
 Zpower & Power of Z gate & constant \\
 \hline 
 \end{tabular}
 \caption{A short summary of variables used in function {\Tt{}make{\_}Ca\nwendquote}}
 
\end{table}


\nwenddocs{}\nwbegincode{23}\sublabel{NW3PuaTs-2eO7lE-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3PuaTs-2eO7lE-1}}}\moddef{Ordinary Ca channel~{\nwtagstyle{}\subpageref{NW3PuaTs-2eO7lE-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3PuaTs-2PoeyK-1}}\nwenddeflinemarkup
# Traub tabulated calcium channel
def make_Ca():
  if moose.exists( 'Ca' ):
      return
  Ca = moose.HHChannel( 'Ca' )
  Ca.Ek = ECA
  Ca.Gbar = 40 * SOMA_A
  Ca.Gk = 0
  Ca.Xpower = 2
  Ca.Ypower = 1
  Ca.Zpower = 0

  xgate = moose.element( 'Ca/gateX' )
  \LA{}setup X-gate using Traub model~{\nwtagstyle{}\subpageref{NW3PuaTs-2TiIIu-1}}\RA{}

  ygate = moose.element( 'Ca/gateY' )
  \LA{}setup Y-gate using Traub model~{\nwtagstyle{}\subpageref{NW3PuaTs-GIuoQ-1}}\RA{}
  \LA{}put information into cell-reader~{\nwtagstyle{}\subpageref{NW3PuaTs-3N4MC8-1}}\RA{}
\nwused{\\{NW3PuaTs-2PoeyK-1}}\nwendcode{}\nwbegindocs{24}\nwdocspar

\paragraph{Set-up X-gate}

  Use {\Tt{}setupAlpha\nwendquote} which is similar to Traub {\Tt{}setupalpaha\nwendquote}. We pass a numpy
  array of 13 elements.

\nwenddocs{}\nwbegincode{25}\sublabel{NW3PuaTs-2TiIIu-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3PuaTs-2TiIIu-1}}}\moddef{setup X-gate using Traub model~{\nwtagstyle{}\subpageref{NW3PuaTs-2TiIIu-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3PuaTs-2eO7lE-1}}\nwenddeflinemarkup
xA = numpy.array( [ 1.6e3, 0, 1.0, -1.0 * (0.065 + EREST_ACT), -0.01389
        , -20e3 * (0.0511 + EREST_ACT), 20e3, -1.0, -1.0 * (0.0511 + EREST_ACT)
        , 5.0e-3, 3000, -0.1, 0.05 ] )
xgate.setupAlpha( xA )
\eatline
\nwused{\\{NW3PuaTs-2eO7lE-1}}\nwendcode{}\nwbegindocs{26}\nwdocspar
\paragraph{Set-up Y-gate}

  The $Y$ gate $gCa/r$ is not quite of this form.  For $V > EREST\_ACT$, $alpha =
  5 \exp(-50(V - \text{EREST\_ACT}))$.  Otherwise, $alpha = 5$.  Over the entire
  range, $alpha + beta = 5$.  To create the {\Tt{}Y{\_}A\nwendquote} and {\Tt{}Y{\_}B\nwendquote} tables, we use some
  of the pieces of the {\Tt{}setupalpha\nwendquote} function.

\nwenddocs{}\nwbegincode{27}\sublabel{NW3PuaTs-GIuoQ-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3PuaTs-GIuoQ-1}}}\moddef{setup Y-gate using Traub model~{\nwtagstyle{}\subpageref{NW3PuaTs-GIuoQ-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3PuaTs-2eO7lE-1}}\nwenddeflinemarkup
ygate.min = -0.1
ygate.max = 0.05
ygate.divs = 3000
yA = numpy.zeros( (ygate.divs + 1), dtype=float)
yB = numpy.zeros( (ygate.divs + 1), dtype=float)

#Fill the Y_A table with alpha values and the Y_B table with (alpha+beta)
dx = (ygate.max - ygate.min)/ygate.divs
x = ygate.min
for i in range( ygate.divs + 1 ):
  if ( x > EREST_ACT):
    yA[i] = 5.0 * math.exp( -50 * (x - EREST_ACT) )
  else:
    yA[i] = 5.0
  yB[i] = 5.0
  x += dx
ygate.tableA = yA
ygate.tableB = yB
\nwused{\\{NW3PuaTs-2eO7lE-1}}\nwendcode{}\nwbegindocs{28}\nwdocspar

\paragraph{Setup cell-reader}

 As we typically use the cell reader to create copies of these prototype
 elements in one or more compartments, we need some way to be sure that the
 needed messages are established.  Although the cell reader has enough
 information to create the messages which link compartments to their channels
 and to other adjacent compartments, it must be provided with the information
 needed to establish additional messages.  This is done by placing the message
 string in a user-defined field of one of the elements which is involved in the
 message.  The cell reader recognizes the added object names "addmsg1",
 "addmsg2", etc. as indicating that they are to be evaluated and used to set up
 messages.  The paths are relative to the element which contains the message
 string in its added field.  Thus, "../Ca\_conc" refers to the sibling element
 {\Tt{}Ca{\_}conc\nwendquote} and "." refers to the Ca element itself.

\nwenddocs{}\nwbegincode{29}\sublabel{NW3PuaTs-3N4MC8-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3PuaTs-3N4MC8-1}}}\moddef{put information into cell-reader~{\nwtagstyle{}\subpageref{NW3PuaTs-3N4MC8-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3PuaTs-2eO7lE-1}}\nwenddeflinemarkup
# Tell the cell reader that the current from this channel must be fed into
# the Ca_conc pool of calcium.
addmsg1 = moose.Mstring( '/library/Ca/addmsg1' )
addmsg1.value = '.  IkOut  ../Ca_conc  current'

# in some compartments, whe have an NMDA_Ca_conc object to put the current
# into.
addmsg2 = moose.Mstring( '/library/Ca/addmsg2' )
addmsg2.value = '.  IkOut  ../NMDA_Ca_conc  current'
\eatline
\nwused{\\{NW3PuaTs-2eO7lE-1}}\nwendcode{}\nwbegindocs{30} 
\paragraph{Convert Ca current to Ca concentration}

  Next, we need an element to take the Calcium current calculated by the Ca
  channel and convert it to the Ca concentration.  The {\Tt{}Ca{\_}concen\nwendquote} object
  solves the equation $\frac{dC}{dt} = B I_{Ca} - \frac{C}{\tau}$, and sets 
  $Ca=Ca_{base} + C$.  As it is easy to make mistakes in units when using
  this Calcium diffusion equation, the units used here merit some discussion.

\begin{note}{Upi's notes on Traub}

  With $Ca_{base} = 0$, this corresponds to Traub's diffusion equation for
  concentration, except that the sign of the current term here is positive, as
  GENESIS uses the convention that {\Tt{}I{\_}Ca\nwendquote} is the current flowing INTO the
  compartment through the channel.  In SI units, the concentration is usually
  expressed in {\Tt{}moles\nwendquote}/$m^3$ (which equals {\Tt{}millimoles/liter\nwendquote}), and the
  units of B are chosen so that $B = \frac{1}{ion\_charge \times \text{Faraday}
  \times \text{volume}}$. Current is expressed in {\Tt{}Amperes\nwendquote} and one
  {\Tt{}Faraday\nwendquote} = 96487 {\Tt{}Coulombs\nwendquote}.  However, in this case, Traub expresses the
  concentration in arbitrary units, current in {\Tt{}micro-Amps\nwendquote} and uses $\tau$ =
  13.33 msec.  If we use the same concentration units, but express current in
  amperes and tau in seconds, our B constant is then $10^{12}$ times the constant
  (called "phi") used in the paper.  The actual value used will be typically be
  determined by the cell reader from the cell parameter file.  However, for the
  prototype channel we wlll use Traub's corrected value for the soma.  (An error
  in the paper gives it as 17,402 rather than 17.402.)  In our units, this will
  be 17.402e12.

\end{note}

\nwenddocs{}\nwbegincode{31}\sublabel{NW3PuaTs-6Nalz-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3PuaTs-6Nalz-1}}}\moddef{Functions to maniputate property of channels~{\nwtagstyle{}\subpageref{NW3PuaTs-6Nalz-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3PuaTs-3Z31po-1}}\nwprevnextdefs{\relax}{NW3PuaTs-6Nalz-2}\nwenddeflinemarkup
def make_Ca_conc():
  if moose.exists( 'Ca_conc' ):
    return
  conc = moose.CaConc( 'Ca_conc' )
  conc.tau = 0.013333  # sec
  conc.B  = 17.402e12 # Curr to conc conversion for soma
  conc.Ca_base = 0.0
\eatline
\nwalsodefined{\\{NW3PuaTs-6Nalz-2}}\nwused{\\{NW3PuaTs-3Z31po-1}}\nwendcode{}\nwbegindocs{32}\nwdocspar
This {\Tt{}Ca{\_}concen\nwendquote} element should receive a message from any calcium channels with
the current going through the channel. Here we have this specified in the Ca
channel, with the idea that more than one channel might contribute Ca ions to
this calcium pool. In the original GENESIS file this was specified here in
{\Tt{}make{\_}Ca{\_}conc\nwendquote}.

\paragraph{Tabulated Ca-dependent Potassium AHP Channel}

This is a {\Tt{}tabchannel\nwendquote} \footnote{Tabulated channel. Instead of computing the
parameter directly, one used look-up table approach} which gets the calcium
concentration from {\Tt{}Ca{\_}conc\nwendquote} in order to calculate the activation of its Z gate.
It is set up much like the Ca channel, except that the A and B tables have
values which are functions of concentration, instead of voltage.

\nwenddocs{}\nwbegincode{33}\sublabel{NW3PuaTs-42jzWM-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3PuaTs-42jzWM-1}}}\moddef{Ca-dependent K-AHP channel~{\nwtagstyle{}\subpageref{NW3PuaTs-42jzWM-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3PuaTs-2PoeyK-1}}\nwenddeflinemarkup
def make_K_AHP():
    if moose.exists( 'K_AHP' ):
        return

    K_AHP = moose.HHChannel( 'K_AHP' )
    K_AHP.Ek = EK                      # V
    K_AHP.Gbar = 8 * SOMA_A            # S
    K_AHP.Gk = 0                       # S
    K_AHP.Xpower = 0
    K_AHP.Ypower = 0
    K_AHP.Zpower = 1

    zgate = moose.element( 'K_AHP/gateZ' )
    xmax = 500.0
    zgate.min = 0
    zgate.max = xmax
    zgate.divs = 3000
    zA = numpy.zeros( (zgate.divs + 1), dtype=float)
    zB = numpy.zeros( (zgate.divs + 1), dtype=float)
    dx = (zgate.max - zgate.min)/zgate.divs
    x = zgate.min
    for i in range( zgate.divs + 1 ):
        if (x < (xmax / 2.0 )):
            zA[i] = 0.02*x
        else:
            zA[i] = 10.0
        zB[i] = zA[i] + 1.0
        x = x + dx

    zgate.tableA = zA
    zgate.tableB = zB

    # Use an added field to tell the cell reader to set up a message from the
    # Ca_Conc with concentration info, to the current K_AHP object.
    addmsg1 = moose.Mstring( '/library/K_AHP/addmsg1' )
    addmsg1.value = '../Ca_conc  concOut  . concen'

\eatline
\nwused{\\{NW3PuaTs-2PoeyK-1}}\nwendcode{}\nwbegindocs{34}\nwdocspar



\paragraph{Ca-dependent Pottasium Channel - K(C) - {\Tt{}vdep{\_}channel\nwendquote} with table
and tabgate}

  The expression for the conductance of the potassium C-current channel has a
  typical voltage and time dependent activation gate, where the time dependence
  arises from the solution of a differential equation containing the rate
  parameters alpha and beta.  It is multiplied by a function of calcium
  concentration that is given explicitly rather than being obtained from a
  differential equation.  Therefore, we need a way to multiply the activation by
  a concentration dependent value which is determined from a lookup table.  This
  is accomplished by using the Z gate with the new tabchannel "instant" field,
  introduced in GENESIS 2.2, to implement an "instantaneous" gate for the
  multiplicative Ca-dependent factor in the conductance.

\nwenddocs{}\nwbegincode{35}\sublabel{NW3PuaTs-45myvV-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3PuaTs-45myvV-1}}}\moddef{Ca-dependent K-C channel~{\nwtagstyle{}\subpageref{NW3PuaTs-45myvV-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3PuaTs-2PoeyK-1}}\nwenddeflinemarkup
def make_K_C():
  if moose.exists( 'K_C'):
    return

  K_C = moose.HHChannel( 'K_C' )
  K_C.Ek = EK          #  V
  K_C.Gbar = 100.0 * SOMA_A   #  S
  K_C.Gk = 0          #  S
  K_C.Xpower = 1
  K_C.Zpower = 1
  K_C.instant = 4        # Flag: 0x100 means Z gate is instant.

  # Now make a X-table for the voltage-dependent activation parameter.
  xgate = moose.element( 'K_C/gateX' )
  xgate.min = -0.1
  xgate.max = 0.05
  xgate.divs = 3000
  xA = numpy.zeros( (xgate.divs + 1), dtype=float)
  xB = numpy.zeros( (xgate.divs + 1), dtype=float)
  dx = (xgate.max - xgate.min)/xgate.divs
  x = xgate.min
  for i in range( xgate.divs + 1 ):
    alpha = 0.0
    beta = 0.0
    if (x < EREST_ACT + 0.05):
      alpha = math.exp( 53.872 * (x - EREST_ACT) - 0.66835 ) / 0.018975
      beta = 2000* (math.exp ( (EREST_ACT + 0.0065 - x)/0.027)) - alpha
    else:
      alpha = 2000 * math.exp( ( EREST_ACT + 0.0065 - x)/0.027 )
      beta = 0.0
    xA[i] = alpha
    xB[i] = alpha + beta
    x = x + dx
  xgate.tableA = xA
  xgate.tableB = xB

    # Create a table for the function of concentration, allowing a
    # concentration range of 0 to 1000, with 50 divisions.  This is done
    # using the Z gate, which can receive a CONCEN message.  By using
    # the "instant" flag, the A and B tables are evaluated as lookup tables,
    #  rather than being used in a differential equation.
  zgate = moose.element( 'K_C/gateZ' )
  zgate.min = 0.0
  xmax = 500.0
  zgate.max = xmax
  zgate.divs = 3000
  zA = numpy.zeros( (zgate.divs + 1), dtype=float)
  zB = numpy.zeros( (zgate.divs + 1), dtype=float)
  dx = ( zgate.max -  zgate.min)/ zgate.divs
  x = zgate.min
  for i in range( xgate.divs + 1 ):
    if ( x < ( xmax / 4.0 ) ):
      zA[i] = x * 4.0 / xmax
    else:
      zA[i] = 1.0
    zB[i] = 1.0
    x += dx
  zgate.tableA = zA
  zgate.tableB = zB
   
   # Now we need to provide for messages that link to external elements.
   # The message that sends the Ca concentration to the Z gate tables is stored
   # in an added field of the channel, so that it may be found by the cell
   # reader.
  addmsg1 = moose.Mstring( '/library/K_C/addmsg1' )
  addmsg1.value = '../Ca_conc  concOut  . concen'
\nwused{\\{NW3PuaTs-2PoeyK-1}}\nwendcode{}\nwbegindocs{36}\nwdocspar

\paragraph{Tabchannel Na Hippocampal cell channel}


\nwenddocs{}\nwbegincode{37}\sublabel{NW3PuaTs-2q0tl2-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3PuaTs-2q0tl2-1}}}\moddef{Tabchannel Na Hippocampal cell channel~{\nwtagstyle{}\subpageref{NW3PuaTs-2q0tl2-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3PuaTs-2PoeyK-1}}\nwenddeflinemarkup
def make_Na():
  if moose.exists( 'Na' ):
    return
  Na = moose.HHChannel( 'Na' )
  Na.Ek = ENA        #  V
  Na.Gbar = 300 * SOMA_A  #  S
  Na.Gk = 0        #  S
  Na.Xpower = 2
  Na.Ypower = 1
  Na.Zpower = 0

  xgate = moose.element( 'Na/gateX' )
  xA = numpy.array( [ 320e3 * (0.0131 + EREST_ACT),
    -320e3, -1.0, -1.0 * (0.0131 + EREST_ACT), -0.004, 
    -280e3 * (0.0401 + EREST_ACT), 280e3, -1.0, 
    -1.0 * (0.0401 + EREST_ACT), 5.0e-3, 
    3000, -0.1, 0.05 ] )
  xgate.setupAlpha( xA )

  ygate = moose.element( 'Na/gateY' )
  yA = numpy.array( [ 128.0, 0.0, 0.0, -1.0 * (0.017 + EREST_ACT), 0.018,
    4.0e3, 0.0, 1.0, -1.0 * (0.040 + EREST_ACT), -5.0e-3, 
    3000, -0.1, 0.05 ] )
  ygate.setupAlpha( yA )

\eatline
\nwused{\\{NW3PuaTs-2PoeyK-1}}\nwendcode{}\nwbegindocs{38}\nwdocspar


\paragraph{Tabchannel K(DR) Hippocampal cell channel}

\nwenddocs{}\nwbegincode{39}\sublabel{NW3PuaTs-1kzgPQ-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3PuaTs-1kzgPQ-1}}}\moddef{Tabchannel K-DR Hippocampal cell channel~{\nwtagstyle{}\subpageref{NW3PuaTs-1kzgPQ-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3PuaTs-2PoeyK-1}}\nwenddeflinemarkup
def make_K_DR():
  if moose.exists( 'K_DR' ):
    return
  K_DR = moose.HHChannel( 'K_DR' )
  K_DR.Ek = EK        #  V
  K_DR.Gbar = 150 * SOMA_A  #  S
  K_DR.Gk = 0        #  S
  K_DR.Xpower = 1
  K_DR.Ypower = 0
  K_DR.Zpower = 0

  xgate = moose.element( 'K_DR/gateX' )
  xA = numpy.array( [ 16e3 * (0.0351 + EREST_ACT), 
    -16e3, -1.0, -1.0 * (0.0351 + EREST_ACT), -0.005,
    250, 0.0, 0.0, -1.0 * (0.02 + EREST_ACT), 0.04,
    3000, -0.1, 0.05 ] )
  xgate.setupAlpha( xA )
\nwused{\\{NW3PuaTs-2PoeyK-1}}\nwendcode{}\nwbegindocs{40}\nwdocspar


\paragraph{Tabchannel K(A) Hippocampal cell channel}

\nwenddocs{}\nwbegincode{41}\sublabel{NW3PuaTs-2nYwmT-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3PuaTs-2nYwmT-1}}}\moddef{Tabchannel K-A Hippocampal cell channell~{\nwtagstyle{}\subpageref{NW3PuaTs-2nYwmT-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3PuaTs-2PoeyK-1}}\nwenddeflinemarkup
def make_K_A():
  if moose.exists( 'K_A' ):
    return
  K_A = moose.HHChannel( 'K_A' )
  K_A.Ek = EK        #  V
  K_A.Gbar = 50 * SOMA_A  #  S
  K_A.Gk = 0        #  S
  K_A.Xpower = 1
  K_A.Ypower = 1
  K_A.Zpower = 0

  xgate = moose.element( 'K_A/gateX' )
  xA = numpy.array( [ 20e3 * (0.0131 + EREST_ACT), 
    -20e3, -1.0, -1.0 * (0.0131 + EREST_ACT), -0.01,
    -17.5e3 * (0.0401 + EREST_ACT), 
    17.5e3, -1.0, -1.0 * (0.0401 + EREST_ACT), 0.01,
    3000, -0.1, 0.05 ] )
  xgate.setupAlpha( xA )

  ygate = moose.element( 'K_A/gateY' )
  yA = numpy.array( [ 1.6, 0.0, 0.0, 0.013 - EREST_ACT, 0.018,
    50.0, 0.0, 1.0, -1.0 * (0.0101 + EREST_ACT), -0.005,
    3000, -0.1, 0.05 ] )
  ygate.setupAlpha( yA )
\eatline
\nwused{\\{NW3PuaTs-2PoeyK-1}}\nwendcode{}\nwbegindocs{42}\nwdocspar
\paragraph{SynChan: Glu receptor}

\nwenddocs{}\nwbegincode{43}\sublabel{NW3PuaTs-1ReWpr-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3PuaTs-1ReWpr-1}}}\moddef{Glu receptor~{\nwtagstyle{}\subpageref{NW3PuaTs-1ReWpr-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3PuaTs-3Z31po-1}}\nwenddeflinemarkup
def make_glu():
  if moose.exists( 'glu' ):
    return
  glu = moose.SynChan( 'glu' )
  glu.Ek = 0.0
  glu.tau1 = 2.0e-3
  glu.tau2 = 9.0e-3
  glu.Gbar = 40 * SOMA_A
\eatline
\nwused{\\{NW3PuaTs-3Z31po-1}}\nwendcode{}\nwbegindocs{44}\nwdocspar

\paragraph{SynChan: NMDA receptor}

\nwenddocs{}\nwbegincode{45}\sublabel{NW3PuaTs-3DOkbq-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3PuaTs-3DOkbq-1}}}\moddef{NMDA receptor~{\nwtagstyle{}\subpageref{NW3PuaTs-3DOkbq-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3PuaTs-3Z31po-1}}\nwprevnextdefs{\relax}{NW3PuaTs-3DOkbq-2}\nwenddeflinemarkup
def make_NMDA():
  if moose.exists( 'NMDA' ):
    return
  NMDA = moose.SynChan( 'NMDA' )
  NMDA.Ek = 0.0
  NMDA.tau1 = 20.0e-3
  NMDA.tau2 = 20.0e-3
  NMDA.Gbar = 5 * SOMA_A

  block = moose.MgBlock( '/library/NMDA/block' )
  block.CMg = 1.2    #  [Mg] in mM
  block.Zk = 2
  block.KMg_A = 1.0/0.28
  block.KMg_B = 1.0/62

  moose.connect( NMDA, 'channelOut', block, 'origChannel', 'OneToOne' )
  addmsg1 = moose.Mstring( '/library/NMDA/addmsg1' )
  addmsg1.value = '.. channel  ./block  channel'
  #Here we want to also tell the cell reader to _remove_ the original
  #Gk, Ek term going from the channel to the compartment, as this is
  # now handled by the MgBlock.
  #addmsg2 = moose.Mstring( 'NMDA/addmsg2'
  #addmsg2.value = 'DropMsg  ..  channel'
  addmsg3 = moose.Mstring( '/library/NMDA/addmsg3' )
  addmsg3.value = '.. VmOut  .  Vm'

\eatline
\nwalsodefined{\\{NW3PuaTs-3DOkbq-2}}\nwused{\\{NW3PuaTs-3Z31po-1}}\nwendcode{}\nwbegindocs{46}\nwdocspar
 The {\Tt{}Ca{\_}NMDA\nwendquote} channel is a subset of the NMDA channel that carries Ca.  It is
 identical to above, except that the Ek for Ca is much higher: 0.08 V from the
 consts at the top of this file.  This is about the reversal potl for 1 uM
 {\Tt{}Ca{\_}in\nwendquote}, 2 mM out.  Also we do not want this channel to contribute to the
 current, which is already accounted for in the main channel. So there is no
 CHANNEL message to the parent compartment.  I would like to have used the
 Nernst to do the Ca potential, and Synchans now take Ek messages but I haven't
 yet used this.

\nwenddocs{}\nwbegincode{47}\sublabel{NW3PuaTs-3DOkbq-2}\nwmargintag{{\nwtagstyle{}\subpageref{NW3PuaTs-3DOkbq-2}}}\moddef{NMDA receptor~{\nwtagstyle{}\subpageref{NW3PuaTs-3DOkbq-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3PuaTs-3Z31po-1}}\nwprevnextdefs{NW3PuaTs-3DOkbq-1}{\relax}\nwenddeflinemarkup
def make_Ca_NMDA():
  if moose.exists( 'Ca_NMDA' ):
    return
  Ca_NMDA = moose.SynChan( 'Ca_NMDA' )
  Ca_NMDA.Ek = ECA
  Ca_NMDA.tau1 = 20.0e-3
  Ca_NMDA.tau2 = 20.0e-3
  Ca_NMDA.Gbar = 5 * SOMA_A

  block = moose.MgBlock( '/library/Ca_NMDA/block' )
  block.CMg = 1.2    #  [Mg] in mM
  block.Zk = 2
  block.KMg_A = 1.0/0.28
  block.KMg_B = 1.0/62

  moose.connect( Ca_NMDA, 'channelOut', block, 'origChannel', 'OneToOne' )
  addmsg1 = moose.Mstring( '/library/Ca_NMDA/addmsg1' )
  addmsg1.value = '.. VmOut  ./block  Vm'
  addmsg2 = moose.Mstring( '/library/Ca_NMDA/addmsg2' )
  addmsg2.value = './block  IkOut ../NMDA_Ca_conc current'
  # The original model has the Ca current also coming here.

\eatline
\nwused{\\{NW3PuaTs-3Z31po-1}}\nwendcode{}\nwbegindocs{48}\nwdocspar
\paragraph{Ca pool for influx through {\Tt{}Ca{\_}NMDA\nwendquote}}

 This pool used to set up Ca info coming to it. Now we insist that the
 originating channel should specify the deferred message.

\nwenddocs{}\nwbegincode{49}\sublabel{NW3PuaTs-6Nalz-2}\nwmargintag{{\nwtagstyle{}\subpageref{NW3PuaTs-6Nalz-2}}}\moddef{Functions to maniputate property of channels~{\nwtagstyle{}\subpageref{NW3PuaTs-6Nalz-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3PuaTs-3Z31po-1}}\nwprevnextdefs{NW3PuaTs-6Nalz-1}{\relax}\nwenddeflinemarkup
def make_NMDA_Ca_conc():
  if moose.exists( 'NMDA_Ca_conc' ):
    return
  NMDA_Ca_conc = moose.CaConc( 'NMDA_Ca_conc' )
  NMDA_Ca_conc.tau = 0.004     # sec. Faster in spine than dend
  NMDA_Ca_conc.B = 17.402e12  # overridden by cellreader.
  NMDA_Ca_conc.Ca_base = 0.0

\eatline
\nwused{\\{NW3PuaTs-3Z31po-1}}\nwendcode{}\nwbegindocs{50}\nwdocspar
\paragraph{Spike Detector}

\nwenddocs{}\nwbegincode{51}\sublabel{NW3PuaTs-1UDn2J-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3PuaTs-1UDn2J-1}}}\moddef{Spike detector~{\nwtagstyle{}\subpageref{NW3PuaTs-1UDn2J-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3PuaTs-3Z31po-1}}\nwenddeflinemarkup
def make_axon():
  if moose.exists( 'axon' ):
    return
  axon = moose.SpikeGen( 'axon' )
  axon.threshold = -40e-3         # V
  axon.abs_refract = 10e-3        # sec
    
\eatline
\nwused{\\{NW3PuaTs-3Z31po-1}}\nwendcode{}\nwbegindocs{52}\nwdocspar


\subsection{Database to keep the XML models}
\label{subsec:database}

  We use sqlite3 database. Let import it and add a section in our class to
  handle this database.

\nwenddocs{}\nwbegincode{53}\sublabel{NW3PuaTs-16aZsn-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3PuaTs-16aZsn-1}}}\moddef{Local imports~{\nwtagstyle{}\subpageref{NW3PuaTs-16aZsn-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3PuaTs-3sbhWR-1}}\nwprevnextdefs{\relax}{NW3PuaTs-16aZsn-2}\nwenddeflinemarkup
import sqlite3 as sql 
\nwalsodefined{\\{NW3PuaTs-16aZsn-2}}\nwused{\\{NW3PuaTs-3sbhWR-1}}\nwendcode{}\nwbegindocs{54}\nwdocspar

\nwenddocs{}\nwbegincode{55}\sublabel{NW3PuaTs-2afNuv-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3PuaTs-2afNuv-1}}}\moddef{methods~{\nwtagstyle{}\subpageref{NW3PuaTs-2afNuv-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3PuaTs-2NXV7C-1}}\nwenddeflinemarkup
\LA{}helper functions~{\nwtagstyle{}\subpageref{NW3PuaTs-47YflN-1}}\RA{}
\LA{}methods to deal with database~{\nwtagstyle{}\subpageref{NW3PuaTs-J34hI-1}}\RA{}
\nwused{\\{NW3PuaTs-2NXV7C-1}}\nwendcode{}\nwbegindocs{56}\nwdocspar

  And lets open a database and initialize it. And add code to clean up the
  connection before exiting the class.

\nwenddocs{}\nwbegincode{57}\sublabel{NW3PuaTs-3OEhdK-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3PuaTs-3OEhdK-1}}}\moddef{initialize members~{\nwtagstyle{}\subpageref{NW3PuaTs-3OEhdK-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3PuaTs-2NXV7C-1}}\nwenddeflinemarkup
self.dbdir = 'db'
self.dbname = 'models.db'
self.dbpath = os.path.join(self.dbdir, self.dbname)
self.includedFiles = list()

if not os.path.exists(self.dbpath) :
  try :
    os.makedirs(self.dbdir)
  except Exception as e :
    debug.printDebug("ERROR"
        , "Faild to create directory \{0\} with error \{1\}".format(self.dbdir, e))
    sys.exit(0)
#self.conn = sql.connect(self.dbpath)
self.conn = sql.connect(":memory:")
self.cursor = self.conn.cursor()
\eatline
\nwused{\\{NW3PuaTs-2NXV7C-1}}\nwendcode{}\nwbegindocs{58}\nwdocspar
\nwenddocs{}\nwbegincode{59}\sublabel{NW3PuaTs-2JMucE-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3PuaTs-2JMucE-1}}}\moddef{clean up the mess~{\nwtagstyle{}\subpageref{NW3PuaTs-2JMucE-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3PuaTs-2NXV7C-1}}\nwenddeflinemarkup
self.cursor.commit()
self.conn.close()
sys.exit()
\eatline
\nwused{\\{NW3PuaTs-2NXV7C-1}}\nwendcode{}\nwbegindocs{60}\nwdocspar
\subsection{Populate database}

    We have the parsed models and we would be searching them extensively when
    combining them together to map onto moose. Populate the sqlite3 database
    such that we can query it easily.

\nwenddocs{}\nwbegincode{61}\sublabel{NW3PuaTs-354DF8-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3PuaTs-354DF8-1}}}\moddef{flow of executation~{\nwtagstyle{}\subpageref{NW3PuaTs-354DF8-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3PuaTs-2NXV7C-1}}\nwenddeflinemarkup
\LA{}initialize database~{\nwtagstyle{}\subpageref{NW3PuaTs-gPg9m-1}}\RA{}
\LA{}populate database with models~{\nwtagstyle{}\subpageref{NW3PuaTs-13SuBd-1}}\RA{}
\LA{}build queries from adaptorML~{\nwtagstyle{}\subpageref{nw@notdef}}\RA{}
\LA{}run queries and generate moose scripts~{\nwtagstyle{}\subpageref{nw@notdef}}\RA{}
\eatline
\nwused{\\{NW3PuaTs-2NXV7C-1}}\nwendcode{}\nwbegindocs{62}\nwdocspar
\paragraph{Populating database}

    Should be directly translated XML to {\Tt{}sqlite3\nwendquote}? No, that would defeat the
    purpose of using sqlite3 in the middle. We must transform the XML as much as
    we can to create a well-defined database which we can simply query and build
    moose scripts. Let's me describe the flow. ETL stands for standard practise
    of \textbf{E}xtract, \textbf{T}ransform, and \textbf{L}oad.

\begin{figure}[h]
\centering
\begin{tikzpicture}
    [every node/.style = {minimum size = 1.5cm}, font=\small]
    
    %\input{macro.tex};
    %\myscript{(0,1)}{3}{4}{hello};

    \node[draw, rectangle] (model1) at (0,0) {\texttt{model1.xml}};
    \node[draw, rectangle] (model2) at (0,2) {\texttt{model2.xml}};
    \node[draw, rectangle] (model3) at (0,4) {\texttt{model3.xml}};
    \node[draw, circle] (db) at (4,2) {\texttt{sqlite3}};
    \node[draw, rectangle] (gen) at (8,2)  {\texttt{moose generator}};
    \node[draw, rectangle] (adaptorML) at (8,4) {adaptorML};
    \node[rectangle] (moose) at (8,0) {moose.py};
    \draw[->] (model1) -- node [below, midway] {ETL} (db);
    \draw[->] (model2) -- node [label={[xshift=0cm,yshift=-0.5cm]ETL}] {} (db);
    \draw[->] (model3) -- node [above, midway] {ETL} (db) -- (gen);
    \draw[->] (adaptorML) -- (gen) -- (moose);

\end{tikzpicture}
\label{fig:multiscale_flow}
\caption{Flow of multi-scale modelling. ETL stands for \textbf{E}xtract
\textbf{T}ransform and \textbf{L}oad.}
\end{figure}


  Now we are ready to do ELT. We are interested in some of XML elements given in
  models which we transform (in Python) and load into database. To transform, we
  extract a part of required XML and build a query which we run to populate the
  database.

\subsection{Transform XML to sqlite3 queries}
\label{subsec:transform}

\nwenddocs{}\nwbegincode{63}\sublabel{NW3PuaTs-J34hI-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3PuaTs-J34hI-1}}}\moddef{methods to deal with database~{\nwtagstyle{}\subpageref{NW3PuaTs-J34hI-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3PuaTs-2afNuv-1}}\nwprevnextdefs{\relax}{NW3PuaTs-J34hI-2}\nwenddeflinemarkup
\LA{}segmentToQuery~{\nwtagstyle{}\subpageref{NW3PuaTs-2vUHI2-1}}\RA{}
\LA{}segmentGroupToQuery~{\nwtagstyle{}\subpageref{NW3PuaTs-3NVAhT-1}}\RA{}
\LA{}biophysicalPropertiesToQuery~{\nwtagstyle{}\subpageref{NW3PuaTs-13HGoA-1}}\RA{}

\eatline
\nwalsodefined{\\{NW3PuaTs-J34hI-2}\\{NW3PuaTs-J34hI-3}\\{NW3PuaTs-J34hI-4}\\{NW3PuaTs-J34hI-5}\\{NW3PuaTs-J34hI-6}}\nwused{\\{NW3PuaTs-2afNuv-1}}\nwendcode{}\nwbegindocs{64}\nwdocspar
\paragraph{Insert a segment into database}
    
    Element {\Tt{}segment\nwendquote} has the following schema in neuroML. While attribute
    {\Tt{}id\nwendquote} is required, {\Tt{}name\nwendquote} is optional. Let's build a query to insert a
    {\Tt{}segment\nwendquote} into database.

\lstinputlisting[firstline=839,lastline=855
,language=XML,frame=single
,caption=XML schema of element \texttt{segment}]{./moose_xml/NeuroML_v2beta1.xsd}

\nwenddocs{}\nwbegincode{65}\sublabel{NW3PuaTs-2vUHI2-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3PuaTs-2vUHI2-1}}}\moddef{segmentToQuery~{\nwtagstyle{}\subpageref{NW3PuaTs-2vUHI2-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3PuaTs-J34hI-1}\\{NW3PuaTs-J34hI-4}}\nwprevnextdefs{\relax}{NW3PuaTs-2vUHI2-2}\nwenddeflinemarkup
def segmentToQuery(self, segXML) :
    values = dict()
    for k in segXML.keys() :
      values[k] = segXML.get(k)
    # get parent, distal and proximal.
    for elem in segXML :
      if self.isTag('parent', elem) :
        values['parent'] = elem.get('segment')
        if elem.get('fractionAlong') :
          values['fractionAlong'] =  elem.get('fractionAlong')
      elif self.isTag('proximal', elem) :
        for k in elem.keys() :
          values["proximal_"+k.strip()] = elem.get(k)
      elif self.isTag('distal', elem) :
        for k in elem.keys() :
          values["distal_"+k.strip()] = elem.get(k)
    # build query
    query = "INSERT OR REPLACE INTO topology ("
    query += ",".join(values.keys())
    query += ') VALUES (' + ", ".join(["'"+v.strip()+"'" for v in values.values()]) + ')'
    return query
\eatline
\nwalsodefined{\\{NW3PuaTs-2vUHI2-2}}\nwused{\\{NW3PuaTs-J34hI-1}\\{NW3PuaTs-J34hI-4}}\nwendcode{}\nwbegindocs{66}\nwdocspar
\paragraph{Segment-group to query}
  
  Schema for this element is following.

\lstinputlisting[firstline=874,lastline=892
    ,language=XML,frame=single
    ,caption=XML schema of element \texttt{segmentGroup}]{./moose_xml/NeuroML_v2beta1.xsd}

\nwenddocs{}\nwbegincode{67}\sublabel{NW3PuaTs-3NVAhT-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3PuaTs-3NVAhT-1}}}\moddef{segmentGroupToQuery~{\nwtagstyle{}\subpageref{NW3PuaTs-3NVAhT-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3PuaTs-J34hI-1}\\{NW3PuaTs-J34hI-4}}\nwprevnextdefs{\relax}{NW3PuaTs-3NVAhT-2}\nwenddeflinemarkup
def insertSegmentGroupsIntoDB(self, segGrpXML) :
    groupId = segGrpXML.get('id')
    for k in segGrpXML :
      query = "UPDATE OR REPLACE topology SET "
      query += "segment_group='"+groupId+"' WHERE id='" + k.get('segment') + "'"
      self.executeQuery(query)

      if 'include' in k.keys() : 
        debug.printDebug("WARN", "Element include is not implemented")
      if 'path' in k.keys() : 
        debug.printDebug("WARN", "Element path is not implemented")
      if 'subTree' in k.keys() :
        debug.printDebug("WARN", "Element subTree is not implemented")
      if 'inhomogeneousParam' in k.keys() : 
        debug.printDebug("WARN", "Element inhomogeneousParam is not implemented")

\eatline
\nwalsodefined{\\{NW3PuaTs-3NVAhT-2}}\nwused{\\{NW3PuaTs-J34hI-1}\\{NW3PuaTs-J34hI-4}}\nwendcode{}\nwbegindocs{68}\nwdocspar
\paragraph{Turn bio-physical properties to queries}

\nwenddocs{}\nwbegincode{69}\sublabel{NW3PuaTs-13HGoA-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3PuaTs-13HGoA-1}}}\moddef{biophysicalPropertiesToQuery~{\nwtagstyle{}\subpageref{NW3PuaTs-13HGoA-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3PuaTs-J34hI-1}\\{NW3PuaTs-J34hI-4}}\nwprevnextdefs{\relax}{NW3PuaTs-13HGoA-2}\nwenddeflinemarkup
def insertBioPhysicalPropertiesIntoDB(self, elemXML) :
    for c in elemXML.getchildren() :
      if self.isTag('membraneProperties', c) :
        for prop in c :
          print prop
      elif self.isTag('intracellularProperties', c) :
        print "Intracellular properties"
      elif self.isTag('extracellularProperties', c) :
        print "Extracellular properties"
      else :
        debug.printDebug("WARN", "Unimplemented element \{0\}".format(c))

\eatline
\nwalsodefined{\\{NW3PuaTs-13HGoA-2}}\nwused{\\{NW3PuaTs-J34hI-1}\\{NW3PuaTs-J34hI-4}}\nwendcode{}\nwbegindocs{70}\subsection{Extract, Transform, and Load}

\nwenddocs{}\nwbegincode{71}\sublabel{NW3PuaTs-13SuBd-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3PuaTs-13SuBd-1}}}\moddef{populate database with models~{\nwtagstyle{}\subpageref{NW3PuaTs-13SuBd-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3PuaTs-354DF8-1}}\nwenddeflinemarkup
for xml in self.xmlDict :
  xmlRootNodeList = self.xmlDict[xml]
  for xmlRootNode in xmlRootNodeList :
    self.extractTransformLoad(xml, xmlRootNode)
\eatline
\nwused{\\{NW3PuaTs-354DF8-1}}\nwendcode{}\nwbegindocs{72}\nwdocspar
  Now the hard part of populating the database starts. We need to initialize the
  database first before we can use it. Its a serious task. Let's initialize
  tables first and document them. The description of database is available in
  section \ref{sec:database}.

\nwenddocs{}\nwbegincode{73}\sublabel{NW3PuaTs-gPg9m-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3PuaTs-gPg9m-1}}}\moddef{initialize database~{\nwtagstyle{}\subpageref{NW3PuaTs-gPg9m-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3PuaTs-354DF8-1}}\nwenddeflinemarkup
self.initDB()
\nwused{\\{NW3PuaTs-354DF8-1}}\nwendcode{}\nwbegindocs{74}\nwdocspar

\nwenddocs{}\nwbegincode{75}\sublabel{NW3PuaTs-J34hI-2}\nwmargintag{{\nwtagstyle{}\subpageref{NW3PuaTs-J34hI-2}}}\moddef{methods to deal with database~{\nwtagstyle{}\subpageref{NW3PuaTs-J34hI-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3PuaTs-2afNuv-1}}\nwprevnextdefs{NW3PuaTs-J34hI-1}{NW3PuaTs-J34hI-3}\nwenddeflinemarkup
def extractTransformLoad(self, modelType, xmlRootNode) :
  if modelType == 'nml' :
    self.etlNMLModel(xmlRootNode)
  else :
      pass 

\eatline
\nwused{\\{NW3PuaTs-2afNuv-1}}\nwendcode{}\nwbegindocs{76}\nwdocspar

\paragraph{ETL a NML model}

  ETL an neuroML model. Model specified in {\Tt{}neuroML\nwendquote}  other
  files too. As soon as we get to know the names of these files, we must demand
  them from the user after parsing of {\Tt{}neuroML\nwendquote} model is over. If these files
  are given from command line, ETL them silently, else demand these files from
  command-line. We'd need {\Tt{}re\nwendquote} library to for pattern matching. 

\nwenddocs{}\nwbegincode{77}\sublabel{NW3PuaTs-16aZsn-2}\nwmargintag{{\nwtagstyle{}\subpageref{NW3PuaTs-16aZsn-2}}}\moddef{Local imports~{\nwtagstyle{}\subpageref{NW3PuaTs-16aZsn-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3PuaTs-3sbhWR-1}}\nwprevnextdefs{NW3PuaTs-16aZsn-1}{\relax}\nwenddeflinemarkup
import re
\nwused{\\{NW3PuaTs-3sbhWR-1}}\nwendcode{}\nwbegindocs{78}\nwdocspar

 Since most of the tags have namespace in them, a function to search a tag would
 be handy.

\nwenddocs{}\nwbegincode{79}\sublabel{NW3PuaTs-47YflN-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3PuaTs-47YflN-1}}}\moddef{helper functions~{\nwtagstyle{}\subpageref{NW3PuaTs-47YflN-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3PuaTs-2afNuv-1}\\{NW3PuaTs-1A5j6P-1}}\nwprevnextdefs{\relax}{NW3PuaTs-47YflN-2}\nwenddeflinemarkup
def isTag(self, tagName, nmElem) :
  if re.search(r'^\\\{(?P<namesapce>[^\}^\{]+)\\\}'+tagName+'\\s*$', nmElem.tag) :
    return True
  else :
    return False
\nwalsodefined{\\{NW3PuaTs-47YflN-2}\\{NW3PuaTs-47YflN-3}}\nwused{\\{NW3PuaTs-2afNuv-1}\\{NW3PuaTs-1A5j6P-1}}\nwendcode{}\nwbegindocs{80}\nwdocspar
\nwenddocs{}\nwbegincode{81}\sublabel{NW3PuaTs-J34hI-3}\nwmargintag{{\nwtagstyle{}\subpageref{NW3PuaTs-J34hI-3}}}\moddef{methods to deal with database~{\nwtagstyle{}\subpageref{NW3PuaTs-J34hI-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3PuaTs-2afNuv-1}}\nwprevnextdefs{NW3PuaTs-J34hI-2}{NW3PuaTs-J34hI-4}\nwenddeflinemarkup
def etlNMLModel(self, nmlTree) :
  debug.printDebug("STEP", "ETLing a nml model")
  nmlRootNode = nmlTree.getroot()
  for c in  [ child  for child in nmlRootNode if type(child.tag) == str] :
    if self.isTag('include', c) :
      self.includedFiles.append(c.get('href'))
    elif self.isTag('cell', c) :
      self.insertCellIntoDB(c)
    else :
      debug.printDebug("WARN", "\{0\} is not implemented yet.".format(child.tag))
 
# Function to insert a cell into database 
def insertCellIntoDB(self, cell) :
  for c in cell.iterchildren(tag=etree.Element) :
    if self.isTag('morphology', c) :
      for elem in c.iterchildren(tag=etree.Element) :
        if self.isTag('segment', elem) :
           segmentDict = dict()
           self.executeQuery(self.segmentToQuery(elem))
        elif self.isTag('segmentGroup', elem) :
           self.insertSegmentGroupsIntoDB(elem)
        else :
          debug.printDebug("INFO" , "This element \{0\} is not supported".format(elem))
    elif self.isTag('biophysicalProperties', c) :
       self.insertBioPhysicalPropertiesIntoDB(c)
    else :
      debug.printDebug("WARN", "\{0\} not implemented".format(c.tag))

\eatline
\nwused{\\{NW3PuaTs-2afNuv-1}}\nwendcode{}\nwbegindocs{82}\nwdocspar
\subsection{Transform XML to sqlite3 queries}
\label{subsec:transform}

\nwenddocs{}\nwbegincode{83}\sublabel{NW3PuaTs-J34hI-4}\nwmargintag{{\nwtagstyle{}\subpageref{NW3PuaTs-J34hI-4}}}\moddef{methods to deal with database~{\nwtagstyle{}\subpageref{NW3PuaTs-J34hI-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3PuaTs-2afNuv-1}}\nwprevnextdefs{NW3PuaTs-J34hI-3}{NW3PuaTs-J34hI-5}\nwenddeflinemarkup
\LA{}segmentToQuery~{\nwtagstyle{}\subpageref{NW3PuaTs-2vUHI2-1}}\RA{}
\LA{}segmentGroupToQuery~{\nwtagstyle{}\subpageref{NW3PuaTs-3NVAhT-1}}\RA{}
\LA{}biophysicalPropertiesToQuery~{\nwtagstyle{}\subpageref{NW3PuaTs-13HGoA-1}}\RA{}

\eatline
\nwused{\\{NW3PuaTs-2afNuv-1}}\nwendcode{}\nwbegindocs{84}\nwdocspar
\paragraph{Insert a segment into database}
    
    Element {\Tt{}segment\nwendquote} has the following schema in neuroML. While attribute
    {\Tt{}id\nwendquote} is required, {\Tt{}name\nwendquote} is optional. Let's build a query to insert a
    {\Tt{}segment\nwendquote} into database.

\lstinputlisting[firstline=839,lastline=855
,language=XML,frame=single
,caption=XML schema of element \texttt{segment}]{./moose_xml/NeuroML_v2beta1.xsd}

\nwenddocs{}\nwbegincode{85}\sublabel{NW3PuaTs-2vUHI2-2}\nwmargintag{{\nwtagstyle{}\subpageref{NW3PuaTs-2vUHI2-2}}}\moddef{segmentToQuery~{\nwtagstyle{}\subpageref{NW3PuaTs-2vUHI2-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3PuaTs-J34hI-1}\\{NW3PuaTs-J34hI-4}}\nwprevnextdefs{NW3PuaTs-2vUHI2-1}{\relax}\nwenddeflinemarkup
def segmentToQuery(self, segXML) :
    values = dict()
    for k in segXML.keys() :
      values[k] = segXML.get(k)
    # get parent, distal and proximal.
    for elem in segXML :
      if self.isTag('parent', elem) :
        values['parent'] = elem.get('segment')
        if elem.get('fractionAlong') :
          values['fractionAlong'] =  elem.get('fractionAlong')
      elif self.isTag('proximal', elem) :
        for k in elem.keys() :
          values["proximal_"+k.strip()] = elem.get(k)
      elif self.isTag('distal', elem) :
        for k in elem.keys() :
          values["distal_"+k.strip()] = elem.get(k)
    # build query
    query = "INSERT OR REPLACE INTO topology ("
    query += ",".join(values.keys())
    query += ') VALUES (' + ", ".join(["'"+v.strip()+"'" for v in values.values()]) + ')'
    return query
\eatline
\nwused{\\{NW3PuaTs-J34hI-1}\\{NW3PuaTs-J34hI-4}}\nwendcode{}\nwbegindocs{86}\nwdocspar
\paragraph{Segment-group to query}
  
  Schema for this element is following.

\lstinputlisting[firstline=874,lastline=892
    ,language=XML,frame=single
    ,caption=XML schema of element \texttt{segmentGroup}]{./moose_xml/NeuroML_v2beta1.xsd}

\nwenddocs{}\nwbegincode{87}\sublabel{NW3PuaTs-3NVAhT-2}\nwmargintag{{\nwtagstyle{}\subpageref{NW3PuaTs-3NVAhT-2}}}\moddef{segmentGroupToQuery~{\nwtagstyle{}\subpageref{NW3PuaTs-3NVAhT-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3PuaTs-J34hI-1}\\{NW3PuaTs-J34hI-4}}\nwprevnextdefs{NW3PuaTs-3NVAhT-1}{\relax}\nwenddeflinemarkup
def insertSegmentGroupsIntoDB(self, segGrpXML) :
    groupId = segGrpXML.get('id')
    for k in segGrpXML :
      query = "UPDATE OR REPLACE topology SET "
      query += "segment_group='"+groupId+"' WHERE id='" + k.get('segment') + "'"
      self.executeQuery(query)

      if 'include' in k.keys() : 
        debug.printDebug("WARN", "Element include is not implemented")
      if 'path' in k.keys() : 
        debug.printDebug("WARN", "Element path is not implemented")
      if 'subTree' in k.keys() :
        debug.printDebug("WARN", "Element subTree is not implemented")
      if 'inhomogeneousParam' in k.keys() : 
        debug.printDebug("WARN", "Element inhomogeneousParam is not implemented")

\eatline
\nwused{\\{NW3PuaTs-J34hI-1}\\{NW3PuaTs-J34hI-4}}\nwendcode{}\nwbegindocs{88}\nwdocspar
\paragraph{Turn bio-physical properties to queries}

\nwenddocs{}\nwbegincode{89}\sublabel{NW3PuaTs-13HGoA-2}\nwmargintag{{\nwtagstyle{}\subpageref{NW3PuaTs-13HGoA-2}}}\moddef{biophysicalPropertiesToQuery~{\nwtagstyle{}\subpageref{NW3PuaTs-13HGoA-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3PuaTs-J34hI-1}\\{NW3PuaTs-J34hI-4}}\nwprevnextdefs{NW3PuaTs-13HGoA-1}{\relax}\nwenddeflinemarkup
def insertBioPhysicalPropertiesIntoDB(self, elemXML) :
    for c in elemXML.getchildren() :
      if self.isTag('membraneProperties', c) :
        for prop in c :
          print prop
      elif self.isTag('intracellularProperties', c) :
        print "Intracellular properties"
      elif self.isTag('extracellularProperties', c) :
        print "Extracellular properties"
      else :
        debug.printDebug("WARN", "Unimplemented element \{0\}".format(c))

\eatline
\nwused{\\{NW3PuaTs-J34hI-1}\\{NW3PuaTs-J34hI-4}}\nwendcode{}\nwbegindocs{90}%%% Description of database
\section{Describe and initialize database}
\label{sec:database}
 
  We have four tables in our database. 

  \begin{table}[h]
  \centering
  \begin{tabular}{lp{10cm}}

    \hline
    
    \texttt{segment} & One entry for each segment along with its
    chemical and electrical properties. Since {\Tt{}parent\nwendquote} is specified for each
    segment, we can figure out the topology from this table only. \\
    
    \texttt{cells} & Types of cell available in this network and their
    properties. \\
    
    \texttt{mapping} & Map a segment to another segment. Specify the relation in
    terms of $lhs=rhsExpr$. \\

    \hline
  \end{tabular}
  \end{table}

  See the chunk {\Tt{}methods\ to\ deal\ with\ database\nwendquote} for table documentation.
  \textbf{All units must be in S.I.}.

\nwenddocs{}\nwbegincode{91}\sublabel{NW3PuaTs-J34hI-5}\nwmargintag{{\nwtagstyle{}\subpageref{NW3PuaTs-J34hI-5}}}\moddef{methods to deal with database~{\nwtagstyle{}\subpageref{NW3PuaTs-J34hI-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3PuaTs-2afNuv-1}}\nwprevnextdefs{NW3PuaTs-J34hI-4}{NW3PuaTs-J34hI-6}\nwenddeflinemarkup
def initDB(self, dropOldTables = False) :
  query = '''CREATE TABLE IF NOT EXISTS topology
    (id INTEGER PRIMARY KEY ASC
    , name VARCHAR
    , parent INTEGER 
    , fractionAlong REAL default '0.0'
    , proximal_x REAL
    , proximal_y REAL 
    , proximal_z REAL
    , proximal_diameter REAL
    , distal_x REAL
    , distal_y REAL
    , distal_z REAL
    , distal_diameter REAL
    , x REAL 
    , y REAL  
    , z REAL 
    , segment_group VARCHAR
    , remark TEXT
    )'''
  self.executeQuery(query)
 
  query = '''CREATE TABLE IF NOT EXISTS electrical
    (type VARCHAR PRIMARY KEY -- Type of cell
    , leakReversal REAL       -- leakReversal potential
    , threshold REAL          -- Threshold voltage
    , reset REAL
    , tau REAL
    , refract REAL
    , capacitance REAL
    , leakConductance REAL
    , a REAL                  -- Izhikenvich Cell model
    , b REAL                  -- Izhikenvich cell model
    , c REAL                  -- Izhikenvich cell model 
    , d REAL                  -- Izhikenvich cell model
    , gL REAL
    , EL REAL
    , VT REAL
    , delT REAL
    , tauw REAL
    , Idel REAL
    , Idur REAL
    )'''
  self.executeQuery(query)

  query = '''CREATE TABLE IF NOT EXISTS mapping
    (id INTEGER
    , seg_from INTEGER, fromType VARCHAR
    , seg_to INTEGER,  toType VARCHAR
    , lhsVar VARCHAR
    , rhsExpr VARCHAR 
    , comment TEXT
    , PRIMARY KEY (seg_from, seg_to, lhsVar)
    )'''
  self.executeQuery(query)

  query = '''CREATE TABLE IF NOT EXISTS property
    (segment_group VARCHAR    -- Group of segment
    , p_name VARCHAR            -- Name of property 
    , p_type VARCHAR            -- type of property 
    , p_value REAL              -- Value of property 
    , p_unit  VARCHAR           -- Unit of property
    , comment TEXT              -- Optional comment 
    )'''
  self.executeQuery(query)


\eatline
\nwused{\\{NW3PuaTs-2afNuv-1}}\nwendcode{}\nwbegindocs{92}\nwdocspar
\paragraph{Execute query}

  This method make sure to roll-back if the query is not executed successfully.

\nwenddocs{}\nwbegincode{93}\sublabel{NW3PuaTs-J34hI-6}\nwmargintag{{\nwtagstyle{}\subpageref{NW3PuaTs-J34hI-6}}}\moddef{methods to deal with database~{\nwtagstyle{}\subpageref{NW3PuaTs-J34hI-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3PuaTs-2afNuv-1}}\nwprevnextdefs{NW3PuaTs-J34hI-5}{\relax}\nwenddeflinemarkup
def executeQuery(self, query) :
  with self.conn :
    try :
      self.cursor.execute(query)
    except Exception as e :
      debug.printDebug("ERR", "Failed to execute query with error \{0\}".format(e))
      print("+ Query was: \{0\}".format(query))

\eatline
\nwused{\\{NW3PuaTs-2afNuv-1}}\nwendcode{}\nwbegindocs{94}\nwdocspar
\section{AdaptorML for Moose}
\label{sec:adaptor}
  
  This adaptor example was writeen by an intern during GSoC. 

 \todo{Write adaptorML}.

%file:moose_xml/adaptor.xml
\nwenddocs{}\nwbegincode{95}\sublabel{NW3PuaTs-3dQJC1-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3PuaTs-3dQJC1-1}}}\moddef{adaptor.xml~{\nwtagstyle{}\subpageref{NW3PuaTs-3dQJC1-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
<?xml version="1.0"?>
  <adapterML>
    <listOfAdaptors>
    <adaptor name="adaptK" id="/n/chem/neuroMesh/adaptK" scale="0.05">
      <inElement name="chemK" id="/n/chem/neuroMesh/kChan" field="get_conc" 
            adapt_type="requestField" mode="OneToAll"/>
      <outElement name="elecK" id="/n/elec/compt/K" field="set_Gbar" 
            adapt_type="outputSrc" mode="OneToAll"/>
    </adaptor>
    <adaptor name="adaptCa" id="/n/chem/neuroMesh/adaptCa" outputOffset="0.0001" scale="0.05">
      <inElement name="elecCa" id="/n/elec/compt/ca" field="concOut" 
            adapt_type="input" mode="OneToAll"/>
      <outElement name="chemCa" id="/n/chem/neuroMesh/Ca" field="set_conc" 
            adapt_type="outputSrc" mode="OneToAll"/>
    </adaptor>
  </listOfAdaptors>
</adapterML>
\eatline
\nwnotused{adaptor.xml}\nwendcode{}\nwbegindocs{96}\section{XML parser}
\label{sec:parser}

  This section deals with parser of XML models. In {\Tt{}multiscale.nw\nwendquote}, we call
  function {\Tt{}parseModels\nwendquote} belonging to this module. This function receives its
  arguments, a dictionary of paths of XML models. These file-paths are already
  verified; they exists and are readable. We now parse the XMLs and return a
  dictionary, with keys as path of XML models and value as top-most XML element.

  Following captures what this module suppose to do.

%file:src/parser.py
\nwenddocs{}\nwbegincode{97}\sublabel{NW3PuaTs-1A5j6P-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3PuaTs-1A5j6P-1}}}\moddef{parser.py~{\nwtagstyle{}\subpageref{NW3PuaTs-1A5j6P-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
\LA{}Import~{\nwtagstyle{}\subpageref{NW3PuaTs-1rIojj-1}}\RA{}
import collections
\LA{}helper functions~{\nwtagstyle{}\subpageref{NW3PuaTs-47YflN-1}}\RA{}
\LA{}function \code{}parseModels\edoc{} for parsing models~{\nwtagstyle{}\subpageref{NW3PuaTs-3zynsH-1}}\RA{}
\nwnotused{parser.py}\nwendcode{}\nwbegindocs{98}\nwdocspar

\paragraph{Parse models}

  Function {\Tt{}parseModels\nwendquote} parses the model, and it creates a dictionary
  containing root elements of parsed files to be returned. This function first
  read the file and validate it with a given schema. Validation can be turned
  on/off by setting the optional argument {\Tt{}validate\nwendquote} to {\Tt{}False\nwendquote}.

\nwenddocs{}\nwbegincode{99}\sublabel{NW3PuaTs-3zynsH-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3PuaTs-3zynsH-1}}}\moddef{function \code{}parseModels\edoc{} for parsing models~{\nwtagstyle{}\subpageref{NW3PuaTs-3zynsH-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3PuaTs-1A5j6P-1}}\nwenddeflinemarkup
def parseModels(commandLineArgs, validate=False) :
  xmlRootElemDict = collections.defaultdict(list)
  models = vars(commandLineArgs)
  for model in models :
    if models[model] :
      for modelPath in models[model] :
        debug.printDebug("INFO", "Parsing \{0\}".format(models[model]))
        if validate :
          # parse model and valid it with schama
          modelXMLRootElem = parseAndValidateWithSchema(model, modelPath)
        else :
          # Simple parse the model without validating it with schema.
          modelXMLRootElem = parseWithoutValidation(model, modelPath)
        if modelXMLRootElem :
          xmlRootElemDict[model].append(modelXMLRootElem)
  return xmlRootElemDict 

\nwused{\\{NW3PuaTs-1A5j6P-1}}\nwendcode{}\nwbegindocs{100} %def parseModels 

\paragraph{Validating with schema}

  We need two helper functions, {\Tt{}parseAndValidateWithSchema\nwendquote} to parse a given
  XML when a schema is available and {\Tt{}parseWithoutValidation\nwendquote} validation is
  off \textbf{schema is not available}. Ideally, schema should be provided as an
  argument to this module, but we can fix their location. Folder {\Tt{}./moose{\_}xml\nwendquote}
  contains the schema we are going to build and use in this application. Its
  path is {\Tt{}./moose{\_}xml/moose.xsd\nwendquote}.

 \todo[size=\small]{Write moose.xsd schema in ./moose\_xml/moose.xsd path.}

\nwenddocs{}\nwbegincode{101}\sublabel{NW3PuaTs-47YflN-2}\nwmargintag{{\nwtagstyle{}\subpageref{NW3PuaTs-47YflN-2}}}\moddef{helper functions~{\nwtagstyle{}\subpageref{NW3PuaTs-47YflN-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3PuaTs-2afNuv-1}\\{NW3PuaTs-1A5j6P-1}}\nwprevnextdefs{NW3PuaTs-47YflN-1}{NW3PuaTs-47YflN-3}\nwenddeflinemarkup
def parseAndValidateWithSchema(modelName, modelPath) :
    
    prefixPath = ''
    if modelName == 'xml' :
      schemaPath = os.path.join(prefixPath, 'moose_xml/moose.xsd')

    try :
      schemaH = open(schemaPath, "r")
      schemaText = schemaH.read()
      schemaH.close()
    except Exception as e :
      debug.printDebug("WARN", "Error reading schema for validation."+
        " Falling back to validation-disabled parser."
        + " Failed with error \{0\}".format(e))
      return parseWithoutValidation(modelName, modelPath)
    # Now we have the schema text 
    schema = etree.XMLSchema(etree.XML(schemaText))
    xmlParser = etree.XMLParser(schema=schema, remove_comments=True)
    with open(modelPath, "r") as xmlTextFile :
        return etree.parse(xmlTextFile, xmlParser)

\eatline
\nwused{\\{NW3PuaTs-2afNuv-1}\\{NW3PuaTs-1A5j6P-1}}\nwendcode{}\nwbegindocs{102}\nwdocspar
\nwenddocs{}\nwbegincode{103}\sublabel{NW3PuaTs-47YflN-3}\nwmargintag{{\nwtagstyle{}\subpageref{NW3PuaTs-47YflN-3}}}\moddef{helper functions~{\nwtagstyle{}\subpageref{NW3PuaTs-47YflN-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3PuaTs-2afNuv-1}\\{NW3PuaTs-1A5j6P-1}}\nwprevnextdefs{NW3PuaTs-47YflN-2}{\relax}\nwenddeflinemarkup
def parseWithoutValidation(modelName, modelPath) :
    xmlParser = etree.XMLParser(remove_comments=True)
    try :
      xmlRootElem = etree.parse(modelPath, xmlParser)
    except Exception as e :
      debug.printDebug("ERROR", "Parsing failed. \{0\}".format(e))
      return 
    return xmlRootElem 

\eatline
\nwused{\\{NW3PuaTs-2afNuv-1}\\{NW3PuaTs-1A5j6P-1}}\nwendcode{}\nwbegindocs{104}\nwdocspar
This ends our parser module and we can now go back to section
\ref{sec:multiscale} to do some real programming related stuff.

\section{Debug module, print debugging messages}
\label{sec:debug}

  Different type of messages are printed in different colors. 

%file:src/debug.py
\nwenddocs{}\nwbegincode{105}\sublabel{NW3PuaTs-3rVy9u-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3PuaTs-3rVy9u-1}}}\moddef{debug.py~{\nwtagstyle{}\subpageref{NW3PuaTs-3rVy9u-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
HEADER = '\\033[95m'
OKBLUE = '\\033[94m'
OKGREEN = '\\033[92m'
WARNING = '\\033[93m'
ERR = '\\033[31m'
ENDC = '\\033[0m'
RED = ERR
WARN = WARNING
INFO = OKBLUE
TODO = OKGREEN
DEBUG = HEADER
ERROR = ERR

prefix = dict(
    ERR = ERR
    , ERROR = ERR
    , WARN = WARN
    , FATAL = ERR
    , INFO = INFO
    , TODO = TODO 
    , NOTE = HEADER 
    , DEBUG = DEBUG
    )

def colored(msg, label) :
    """
    Return a colored string. Formatting is optional.
    """
    global prefix
    if label in prefix :
        color = prefix[label]
    else :
        color = ""
    return "[\{0\}] \{1\} \{2\}".format(label, color+msg, ENDC)

def printDebug(label, msg):
    print(colored(msg, label))

\eatline
\nwnotused{debug.py}\nwendcode{}

\nwixlogsorted{c}{{adaptor.xml}{NW3PuaTs-3dQJC1-1}{\nwixd{NW3PuaTs-3dQJC1-1}}}%
\nwixlogsorted{c}{{argument parser}{NW3PuaTs-86zu3-1}{\nwixu{NW3PuaTs-FYkKg-1}\nwixd{NW3PuaTs-86zu3-1}}}%
\nwixlogsorted{c}{{biophysicalPropertiesToQuery}{NW3PuaTs-13HGoA-1}{\nwixu{NW3PuaTs-J34hI-1}\nwixd{NW3PuaTs-13HGoA-1}\nwixu{NW3PuaTs-J34hI-4}\nwixd{NW3PuaTs-13HGoA-2}}}%
\nwixlogsorted{c}{{build queries from adaptorML}{nw@notdef}{\nwixu{NW3PuaTs-354DF8-1}}}%
\nwixlogsorted{c}{{Ca-dependent K-AHP channel}{NW3PuaTs-42jzWM-1}{\nwixu{NW3PuaTs-2PoeyK-1}\nwixd{NW3PuaTs-42jzWM-1}}}%
\nwixlogsorted{c}{{Ca-dependent K-C channel}{NW3PuaTs-45myvV-1}{\nwixu{NW3PuaTs-2PoeyK-1}\nwixd{NW3PuaTs-45myvV-1}}}%
\nwixlogsorted{c}{{clean up the mess}{NW3PuaTs-2JMucE-1}{\nwixu{NW3PuaTs-2NXV7C-1}\nwixd{NW3PuaTs-2JMucE-1}}}%
\nwixlogsorted{c}{{debug.py}{NW3PuaTs-3rVy9u-1}{\nwixd{NW3PuaTs-3rVy9u-1}}}%
\nwixlogsorted{c}{{Define constants}{NW3PuaTs-n1AAP-1}{\nwixu{NW3PuaTs-3Z31po-1}\nwixd{NW3PuaTs-n1AAP-1}}}%
\nwixlogsorted{c}{{Definition of class \code{}Multiscale\edoc{}}{NW3PuaTs-2NXV7C-1}{\nwixu{NW3PuaTs-3sbhWR-1}\nwixd{NW3PuaTs-2NXV7C-1}}}%
\nwixlogsorted{c}{{flow of executation}{NW3PuaTs-354DF8-1}{\nwixu{NW3PuaTs-2NXV7C-1}\nwixd{NW3PuaTs-354DF8-1}}}%
\nwixlogsorted{c}{{function \code{}parseModels\edoc{} for parsing models}{NW3PuaTs-3zynsH-1}{\nwixu{NW3PuaTs-1A5j6P-1}\nwixd{NW3PuaTs-3zynsH-1}}}%
\nwixlogsorted{c}{{functions in main}{NW3PuaTs-4IIwDq-1}{\nwixu{NW3PuaTs-FYkKg-1}\nwixd{NW3PuaTs-4IIwDq-1}}}%
\nwixlogsorted{c}{{Functions to create channels}{NW3PuaTs-2PoeyK-1}{\nwixu{NW3PuaTs-3Z31po-1}\nwixd{NW3PuaTs-2PoeyK-1}}}%
\nwixlogsorted{c}{{Functions to maniputate property of channels}{NW3PuaTs-6Nalz-1}{\nwixu{NW3PuaTs-3Z31po-1}\nwixd{NW3PuaTs-6Nalz-1}\nwixd{NW3PuaTs-6Nalz-2}}}%
\nwixlogsorted{c}{{Glu receptor}{NW3PuaTs-1ReWpr-1}{\nwixu{NW3PuaTs-3Z31po-1}\nwixd{NW3PuaTs-1ReWpr-1}}}%
\nwixlogsorted{c}{{hand over control to class in multiscale module}{NW3PuaTs-1butCV-1}{\nwixu{NW3PuaTs-4bnFmj-1}\nwixd{NW3PuaTs-1butCV-1}}}%
\nwixlogsorted{c}{{helper functions}{NW3PuaTs-47YflN-1}{\nwixu{NW3PuaTs-2afNuv-1}\nwixd{NW3PuaTs-47YflN-1}\nwixu{NW3PuaTs-1A5j6P-1}\nwixd{NW3PuaTs-47YflN-2}\nwixd{NW3PuaTs-47YflN-3}}}%
\nwixlogsorted{c}{{Import}{NW3PuaTs-1rIojj-1}{\nwixd{NW3PuaTs-1rIojj-1}\nwixu{NW3PuaTs-FYkKg-1}\nwixu{NW3PuaTs-3sbhWR-1}\nwixu{NW3PuaTs-1A5j6P-1}}}%
\nwixlogsorted{c}{{initialize database}{NW3PuaTs-gPg9m-1}{\nwixu{NW3PuaTs-354DF8-1}\nwixd{NW3PuaTs-gPg9m-1}}}%
\nwixlogsorted{c}{{initialize members}{NW3PuaTs-3OEhdK-1}{\nwixu{NW3PuaTs-2NXV7C-1}\nwixd{NW3PuaTs-3OEhdK-1}}}%
\nwixlogsorted{c}{{Local imports}{NW3PuaTs-16aZsn-1}{\nwixu{NW3PuaTs-3sbhWR-1}\nwixd{NW3PuaTs-16aZsn-1}\nwixd{NW3PuaTs-16aZsn-2}}}%
\nwixlogsorted{c}{{main.py}{NW3PuaTs-FYkKg-1}{\nwixd{NW3PuaTs-FYkKg-1}}}%
\nwixlogsorted{c}{{methods}{NW3PuaTs-2afNuv-1}{\nwixu{NW3PuaTs-2NXV7C-1}\nwixd{NW3PuaTs-2afNuv-1}}}%
\nwixlogsorted{c}{{methods to deal with database}{NW3PuaTs-J34hI-1}{\nwixu{NW3PuaTs-2afNuv-1}\nwixd{NW3PuaTs-J34hI-1}\nwixd{NW3PuaTs-J34hI-2}\nwixd{NW3PuaTs-J34hI-3}\nwixd{NW3PuaTs-J34hI-4}\nwixd{NW3PuaTs-J34hI-5}\nwixd{NW3PuaTs-J34hI-6}}}%
\nwixlogsorted{c}{{multiscale}{NW3PuaTs-3sbhWR-1}{\nwixd{NW3PuaTs-3sbhWR-1}}}%
\nwixlogsorted{c}{{NMDA receptor}{NW3PuaTs-3DOkbq-1}{\nwixu{NW3PuaTs-3Z31po-1}\nwixd{NW3PuaTs-3DOkbq-1}\nwixd{NW3PuaTs-3DOkbq-2}}}%
\nwixlogsorted{c}{{Ordinary Ca channel}{NW3PuaTs-2eO7lE-1}{\nwixu{NW3PuaTs-2PoeyK-1}\nwixd{NW3PuaTs-2eO7lE-1}}}%
\nwixlogsorted{c}{{parse xml models and handover control to main class}{NW3PuaTs-4bnFmj-1}{\nwixu{NW3PuaTs-FYkKg-1}\nwixd{NW3PuaTs-4bnFmj-1}}}%
\nwixlogsorted{c}{{parser.py}{NW3PuaTs-1A5j6P-1}{\nwixd{NW3PuaTs-1A5j6P-1}}}%
\nwixlogsorted{c}{{populate database with models}{NW3PuaTs-13SuBd-1}{\nwixu{NW3PuaTs-354DF8-1}\nwixd{NW3PuaTs-13SuBd-1}}}%
\nwixlogsorted{c}{{proto.py}{NW3PuaTs-3Z31po-1}{\nwixd{NW3PuaTs-3Z31po-1}}}%
\nwixlogsorted{c}{{put information into cell-reader}{NW3PuaTs-3N4MC8-1}{\nwixu{NW3PuaTs-2eO7lE-1}\nwixd{NW3PuaTs-3N4MC8-1}}}%
\nwixlogsorted{c}{{run queries and generate moose scripts}{nw@notdef}{\nwixu{NW3PuaTs-354DF8-1}}}%
\nwixlogsorted{c}{{segmentGroupToQuery}{NW3PuaTs-3NVAhT-1}{\nwixu{NW3PuaTs-J34hI-1}\nwixd{NW3PuaTs-3NVAhT-1}\nwixu{NW3PuaTs-J34hI-4}\nwixd{NW3PuaTs-3NVAhT-2}}}%
\nwixlogsorted{c}{{segmentToQuery}{NW3PuaTs-2vUHI2-1}{\nwixu{NW3PuaTs-J34hI-1}\nwixd{NW3PuaTs-2vUHI2-1}\nwixu{NW3PuaTs-J34hI-4}\nwixd{NW3PuaTs-2vUHI2-2}}}%
\nwixlogsorted{c}{{setup X-gate using Traub model}{NW3PuaTs-2TiIIu-1}{\nwixu{NW3PuaTs-2eO7lE-1}\nwixd{NW3PuaTs-2TiIIu-1}}}%
\nwixlogsorted{c}{{setup Y-gate using Traub model}{NW3PuaTs-GIuoQ-1}{\nwixu{NW3PuaTs-2eO7lE-1}\nwixd{NW3PuaTs-GIuoQ-1}}}%
\nwixlogsorted{c}{{Spike detector}{NW3PuaTs-1UDn2J-1}{\nwixu{NW3PuaTs-3Z31po-1}\nwixd{NW3PuaTs-1UDn2J-1}}}%
\nwixlogsorted{c}{{Tabchannel K-A Hippocampal cell channell}{NW3PuaTs-2nYwmT-1}{\nwixu{NW3PuaTs-2PoeyK-1}\nwixd{NW3PuaTs-2nYwmT-1}}}%
\nwixlogsorted{c}{{Tabchannel K-DR Hippocampal cell channel}{NW3PuaTs-1kzgPQ-1}{\nwixu{NW3PuaTs-2PoeyK-1}\nwixd{NW3PuaTs-1kzgPQ-1}}}%
\nwixlogsorted{c}{{Tabchannel Na Hippocampal cell channel}{NW3PuaTs-2q0tl2-1}{\nwixu{NW3PuaTs-2PoeyK-1}\nwixd{NW3PuaTs-2q0tl2-1}}}%
\nwixlogsorted{c}{{tests}{nw@notdef}{\nwixu{NW3PuaTs-2NXV7C-1}}}%
\nwbegindocs{106}\nwdocspar
\nowebchunks
\nowebindex
\listoftodos
\end{document}          
\nwenddocs{}
